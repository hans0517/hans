## Array
前面課程中提到過。比如int a[8];語句。定義一個能存儲8個整型數據的數組a，系統會為數組a 分配一片連續的存儲空間（例如，1201~1232），數組中元素按下標從小到大排列，每個元素佔用相應的4個字節。另外，數組名a是常量，代表數組佔用存儲空間的起始地址
![image](https://github.com/hans0517/hans/blob/master/images/CS50-1.png)

## Linked List
首先，需要有一個指針指向列表的第一個元素，知道鍊錶從哪兒開始的。然後，每個元素除了數據域存儲數據，還有指針域指向下一個元素。然後，不需要連續的存儲空間，只要有指針存儲下一個元素的地址就行。鍊錶的最後一個元素指針指向Null，標誌這鍊錶的結尾

![image](https://github.com/hans0517/hans/blob/master/images/CS50-2.png)

例如，如果要在上述鍊錶中搜索一個元素02：首先通過頭指針查看頭指針指向的元素值是否等於02，發現不等於，查看指針指向的下一個元素值是否等於02，最後發現有個元素等於02，返回True。如果直到指針指向Null，都沒有發現搜索元素，返回False。


鍊錶中增加元素（到鍊錶開頭），如下圖：複製頭指針的地址，使要增加的元素同樣指向第一個元素。使頭指針指向要增加的這個元素。

![image](https://github.com/hans0517/hans/blob/master/images/CS50-3.png)
![image](https://github.com/hans0517/hans/blob/master/images/CS50-4.png)

## Stack
每次增加元素會放在棧頂，每次也只能取出棧頂的元素。影片中有兩個例子，顯示餐廳的托盤，一大堆托盤，放托盤時，只能放在最上面。拿托盤時，也只能拿最上面的。還有疊衣服到箱子裡，每次放衣服放在最上面，拿衣服也只能拿最上面的，一直只能穿一套衣服。

## Queue
假如隊列只有8個位置。現在8個位置都有人排隊。第一個人買完後，又來了一個人排隊。一般的做法是所有的人前移一個位置，留出最後一個位置給新來的人。更巧妙的做法，可以新來的人直接站在第一個位置。只要第二個人的位置變成隊列的開頭就行了。

![image](https://github.com/hans0517/hans/blob/master/images/CS50-5.png)
